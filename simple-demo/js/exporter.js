/**
 * Exporter Module for Mood Notetaker
 * Allows exporting the session data (emotions, transcript, summary) as a Markdown file
 */

class Exporter {
  constructor() {
    this.emotions = [];
    this.transcript = '';
    this.summary = '';
    this.sessionTimestamp = new Date().toISOString();
  }

  /**
   * Log an emotion for the timeline
   * @param {string} emotion The detected emotion
   * @param {number} timestamp The time of detection
   */
  logEmotion(emotion, timestamp = Date.now()) {
    this.emotions.push({
      emotion,
      timestamp,
      relativeTime: ((timestamp - this.sessionStartTime) / 1000).toFixed(1) + 's'
    });
  }

  /**
   * Start a new session
   */
  startSession() {
    this.emotions = [];
    this.transcript = '';
    this.summary = '';
    this.sessionStartTime = Date.now();
    this.sessionTimestamp = new Date().toLocaleString();
  }

  /**
   * Update the transcript
   * @param {string} text The latest transcript text
   */
  updateTranscript(text) {
    this.transcript = text;
  }

  /**
   * Update the summary
   * @param {string} text The latest summary text
   */
  updateSummary(text) {
    this.summary = text;
  }

  /**
   * Generate a Markdown representation of the session
   * @returns {string} The Markdown content
   */
  generateMarkdown() {
    const emotionCounts = this.countEmotions();
    const dominantEmotion = this.getDominantEmotion(emotionCounts);
    
    let markdown = `# Mood Notetaker Session\n\n`;
    markdown += `*Session recorded: ${this.sessionTimestamp}*\n\n`;
    
    markdown += `## Summary\n\n${this.summary || '*No summary generated*'}\n\n`;
    
    markdown += `## Emotion Analysis\n\n`;
    markdown += `**Dominant Emotion:** ${dominantEmotion}\n\n`;
    
    markdown += `### Emotion Timeline\n\n`;
    if (this.emotions.length > 0) {
      markdown += `| Time | Emotion |\n|------|--------|\n`;
      this.emotions.forEach(e => {
        markdown += `| ${e.relativeTime} | ${e.emotion} |\n`;
      });
    } else {
      markdown += `*No emotions recorded*\n`;
    }
    
    markdown += `\n### Emotion Distribution\n\n`;
    for (const [emotion, count] of Object.entries(emotionCounts)) {
      const percentage = Math.round((count / this.emotions.length) * 100) || 0;
      const bar = 'â–“'.repeat(Math.ceil(percentage / 5));
      markdown += `${emotion}: ${bar} ${percentage}%\n`;
    }
    
    markdown += `\n## Full Transcript\n\n`;
    markdown += this.transcript || '*No transcript recorded*';
    
    markdown += `\n\n---\n\n*Generated by Mood Notetaker*`;
    
    return markdown;
  }

  /**
   * Count occurrences of each emotion
   * @returns {Object} Counts of each emotion
   */
  countEmotions() {
    const counts = {
      'happy': 0,
      'sad': 0,
      'angry': 0,
      'surprised': 0,
      'fearful': 0,
      'disgusted': 0,
      'neutral': 0
    };
    
    this.emotions.forEach(e => {
      if (counts[e.emotion.toLowerCase()] !== undefined) {
        counts[e.emotion.toLowerCase()]++;
      }
    });
    
    return counts;
  }

  /**
   * Get the dominant emotion from counts
   * @param {Object} counts Emotion counts
   * @returns {string} The dominant emotion
   */
  getDominantEmotion(counts) {
    if (this.emotions.length === 0) return 'None detected';
    
    let maxEmotion = 'neutral';
    let maxCount = 0;
    
    for (const [emotion, count] of Object.entries(counts)) {
      if (count > maxCount) {
        maxCount = count;
        maxEmotion = emotion;
      }
    }
    
    return maxEmotion.charAt(0).toUpperCase() + maxEmotion.slice(1);
  }

  /**
   * Export the session data as a Markdown file
   */
  exportSession() {
    const markdown = this.generateMarkdown();
    const blob = new Blob([markdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `mood-notetaker-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.md`;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }
}

// Export the Exporter class
window.Exporter = Exporter; 